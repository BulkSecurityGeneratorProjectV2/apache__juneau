<!--
/***************************************************************************************************************************
 * Licensed to the Apache Software Foundation (ASF) under one or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *  
 *  http://www.apache.org/licenses/LICENSE-2.0
 *  
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations under the License.
 ***************************************************************************************************************************/
 -->

8.1.4 (TBD)

<p>
</p>

<h5 class='topic w800'>juneau-marshall</h5>
<ul class='spaced-list'>
	<li>
		{@link oaj.annotation.Bean @Bean} and {@link oaj.annotation.BeanIgnore @BeanIgnore} annotations can alternately occur in parent class hierarchy.
		The first one found dictates whether a class is ignored as a bean or not.
	<li>
		Applying the {@link oaj.annotation.Bean @Bean} annotation on a class will now force non-public classes to be interpreted as beans.
		For example, applying {@link oaj.annotation.Bean @Bean} to a <jk>private</jk> class will force it to be treated as a bean.
		<br>
		Also, if a public bean constructor cannot be found, the default constructor will be used 
		regardless of it's visibility if the {@link oaj.annotation.Bean @Bean} annotation is on the class.
	<li>
		The <ja>@Beanc</ja> annotation can now be recognized and used on non-public constructors.
	<li>
		Annotations are now aggregated across the entire class hierarchy instead of simply being overridden.
		<br>The following is an example.
		<p class='bpcode w800'>
	<jc>// Parent class with properties a,b,c</jc>
	<ja>@Bean</ja>(bpi=<js>"a,b,c"</js>)
	<jk>public class</jk> MyClass {
		<jk>public int</jk> a, b, c, d;
	}
	
	<jc>// New behavior:  Child class with properties a,c because @Beans are aggregated.</jc>
	<jc>// Old behavior:  Child class with properties a,c,d because @Bean is overridden.</jc>
	<ja>@Bean</ja>(bpx=<js>"b"</js>)
	<jk>public class</jk> MyClass {
		<jk>public int</jk> a, b, c, d;
	}
		</p>
	<li>
		Include/exclude/read-only/write-only properties defined on the bean context now override those defined on 
		annotations of the class itself.  For example, the following methods override the {@link oaj.annotation.Bean @Bean} 
		annotations on classes:
		<ul class='javatree'>
			<li class='jc'>{@link oaj.BeanContextBuilder}
			<ul>
				<li class='jm'>{@link oaj.BeanContextBuilder#bpi(String) bpi(String)}
				<li class='jm'>{@link oaj.BeanContextBuilder#bpx(String) bpx(String)}
				<li class='jm'>{@link oaj.BeanContextBuilder#bpro(String) bpro(String)}
				<li class='jm'>{@link oaj.BeanContextBuilder#bpwo(String) bpwo(String}
			</ul>
		</ul>
	<li>
		Config annotations now override class-level annotations.
		<br>For example, only the 'a' and 'b' properties get serialized on the bean below:
		<p class='bpcode w800'>
	<jc>// Parent class with properties a,b,c</jc>
	<ja>@Bean</ja>(bpi=<js>"a,b,c"</js>)
	<jk>public class</jk> MyClass {
		<jk>public int</jk> a, b, c, d;
	}

	<ja>@RestMethod</ja>
	<ja>@BeanConfig</ja>(beanApply={<ja>@Bean</ja>(on=<js>"MyClass"</js>,bpi=<js>"a,b"</js>)}
	<jk>public</jk> MyClass getMyClass() {...}
		</p>
	<li>
		The following concrete annotation implementation classes are now provided that can be used with the {@link oaj.BeanContextBuilder#annotations(Annotation)} method:
		<ul class='javatree'>
			<li class'jc'>{@link oaj.annotation.BeanAnnotation} <jk>implements</jk> {@link oaj.annotation.BeanAnnotation}
			<li class'jc'>{@link oaj.annotation.BeancAnnotation} <jk>implements</jk> {@link oaj.annotation.BeancAnnotation}
			<li class'jc'>{@link oaj.annotation.BeanIgnoreAnnotation} <jk>implements</jk> {@link oaj.annotation.BeanIgnoreAnnotation}
			<li class'jc'>{@link oaj.annotation.BeanpAnnotation} <jk>implements</jk> {@link oaj.annotation.BeanpAnnotation}
			<li class'jc'>{@link oaj.annotation.ExampleAnnotation} <jk>implements</jk> {@link oaj.annotation.ExampleAnnotation}
			<li class'jc'>{@link oaj.annotation.NamePropertyAnnotation} <jk>implements</jk> {@link oaj.annotation.NamePropertyAnnotation}
			<li class'jc'>{@link oaj.annotation.ParentPropertyAnnotation} <jk>implements</jk> {@link oaj.annotation.ParentPropertyAnnotation}
			<li class'jc'>{@link oaj.annotation.SwapAnnotation} <jk>implements</jk> {@link oaj.annotation.SwapAnnotation}
			<li class'jc'>{@link oaj.annotation.UriAnnotation} <jk>implements</jk> {@link oaj.annotation.UriAnnotation}
			<li class'jc'>{@link oaj.csv.annotation.CsvAnnotation} <jk>implements</jk> {@link oaj.annotation.CsvAnnotation}
			<li class'jc'>{@link oaj.html.annotation.HtmlAnnotation} <jk>implements</jk> {@link oaj.annotation.HtmlAnnotation}
			<li class'jc'>{@link oaj.jso.annotation.JsoAnnotation} <jk>implements</jk> {@link oaj.annotation.JsoAnnotation}
			<li class'jc'>{@link oaj.json.annotation.JsonAnnotation} <jk>implements</jk> {@link oaj.annotation.JsonAnnotation}
			<li class'jc'>{@link oaj.jsonschema.annotation.SchemaAnnotation} <jk>implements</jk> {@link oaj.annotation.SchemaAnnotation}
			<li class'jc'>{@link oaj.msgpack.annotation.MsgPackAnnotation} <jk>implements</jk> {@link oaj.annotation.MsgPackAnnotation}
			<li class'jc'>{@link oaj.oapi.annotation.OpenApiAnnotation} <jk>implements</jk> {@link oaj.annotation.OpenApiAnnotation}
			<li class'jc'>{@link oaj.plaintext.annotation.PlainTextAnnotation} <jk>implements</jk> {@link oaj.annotation.PlainTextAnnotation}
			<li class'jc'>{@link oaj.soap.annotation.SoapXmlAnnotation} <jk>implements</jk> {@link oaj.annotation.SoapXmlAnnotation}
			<li class'jc'>{@link oaj.uon.annotation.UonAnnotation} <jk>implements</jk> {@link oaj.annotation.UonAnnotation}
			<li class'jc'>{@link oaj.urlencoding.annotation.UrlEncodingAnnotation} <jk>implements</jk> {@link oaj.annotation.UrlEncodingAnnotation}
			<li class'jc'>{@link oaj.xml.annotation.XmlAnnotation} <jk>implements</jk> {@link oaj.annotation.XmlAnnotation}
		</ul>
		<br>Example:
		<p class='bpcode w800'>
	<ja>@Bean</ja>(bpi=<js>"street,city"</js>) <jc>// Will be overridden</jc>
	<jk>public class</jk> AddressBean {...}
	
	<ja>Bean</ja> ba = <jk>new</jk> BeanAnnotation(<js>"AddressBean"</js>).bpi(<js>"street,city,state"</js>);
	WriterSerializer ws = JsonSerializer.<jsm>create</jsm>().annotations(ba).build();
	String json = ws.toString(addressBean);  <jc>// Will print street,city,state</jc>
		</p>
	<li>
		Bean maps now have the concept of "hidden" properties (properties that aren't serialized but otherwise accessible).
		<br>For example, the {@link oaj.html.annotation.Html#link()} can now reference hidden properties:
		<p class='bpcode w800'>
	<ja>@Bean</ja>(bpi=<js>"a"</js>) <jc>// Will be overridden</jc>
	<jk>public class</jk> MyBean {
		
		<ja>@Html</ja>(link=<js>"servlet:/{b}"</js>)
		<jk>public</jk> String <jf>a</jf>;
		
		<jk>public</jk> String <jf>b</jf>;  <jc>// Not serialized, but referenced in link on a.</jc>  
			
	}
		</p>
		<br>
		The general rule for the {@link oaj.BeanMap} class is that <c>get()</c>,<c>put()</c>, and <c>containsKey()</c>
		will work against hidden properties, but <c>keySet()</c> and <c>entrySet()</c> will skip them.
	<li>
		Several bug fixes in the {@link HtmlSerializer} and {@link HtmlParser} classes around the handling of 
		collections and arrays of beans with <c><ja>@Bean</ja>(typeName)</c> annotations.
	<li>
		New {@link oaj.ObjectMap(Object...)} constructor.
	<li>
		New swaps auto-added to all serializers/parsers:
		<ul>
			<li class='jc'>{@link oaj.transforms.MatchResultSwap} 
			<li class='jc'>{@link oaj.transforms.StackTraceElementSwap} 
		</ul>		
	<li>
		{@link oaj.html.annotation.Html#noTableHeaders} now can be applied to collections of beans.
	<li>
		New {@link oaj.html.annotation.HtmlDoc#asideFloat} setting so that you can position the contents of the aside section on the page.
	<li>
		Various minor fixes surrounding HTML serialization.
		<ul>
			<li>Collections of beans that were supposed to be serialized as tables were being serialized as lists.
			<li>Collections of beans with <c><ja>@Bean</ja>(bpi)</c> were not being serialized in the correct column order.			
		</ul>
	<li>
		Fixed a bug where a copy constructor can erroneously be recognised as a builder constructor if the class also
		has a static <c>create</c> method.  Net effect was that the copy constructor would needlessly be called during parsing.
	<li>
		HTML-Schema support is being deprecated due to low-use and difficulty in maintaining.  It will be removed in 9.0.
</ul>

<h5 class='topic w800'>juneau-rest-server</h5>
<ul class='spaced-list'>
	<li>
		{@link oajr.annotation.Rest}-annotated classes can now implement the following interfaces directly instead of having
		to define secondary classes and hook them up through annotations:
		<ul>
			<li class='jic'>{@link oajr.RestCallHandler} - Normally defined through {@link oajr.annotation.Rest#callHandler() @Rest.callHandler()}.
			<li class='jic'>{@link oajr.RestInfoProvider} - Normally defined through {@link oajr.annotation.Rest#infoProvider() @Rest.infoProvider()}.
			<li class='jic'>{@link oajr.RestCallLogger} - Normally defined through {@link oajr.annotation.Rest#callLogger() @Rest.callLogger()}.
		</ul>
	<li>
		{@link oajr.RestServlet} now implements the {@link oajr.RestCallHandler}, {@link oajr.RestInfoProvider}, and {@link oajr.RestCallLogger}
		interfaces directly and provides the same functionality as {@link oajr.BasicRestCallHandler}, {@link oajr.BasicRestInfoProvider}, and
		{@link oajr.BasicRestCallLogger}.  This makes it easier to tweak these methods without having to implement your own classes.
		<br>The methods added for {@link oajr.RestCallHandler} are:
		<ul>
			<li class='jac'>{@link oaj.RestServlet}
			<ul>
				<li class='jm'>{@link oaj.RestServlet#execute(HttpServletRequest, HttpServletResponse) execute(HttpServletRequest, HttpServletResponse)}
				<li class='jm'>{@link oaj.RestServlet#createCall(HttpServletRequest, HttpServletResponse) createCall(HttpServletRequest, HttpServletResponse)}
				<li class='jm'>{@link oaj.RestServlet#createRequest(RestCall) createRequest(RestCall)}
				<li class='jm'>{@link oaj.RestServlet#createResponse(RestCall) createResponse(RestCall)}
				<li class='jm'>{@link oaj.RestServlet#handleResponse(RestCall) handleResponse(RestCall)}
				<li class='jm'>{@link oaj.RestServlet#handleNotFound(RestCall) handleNotFound(RestCall)}
				<li class='jm'>{@link oaj.RestServlet#handleError(RestCall,Throwable) handleError(RestCall,Throwable)}
				<li class='jm'>{@link oaj.RestServlet#convertThrowable(Throwable) throwable(Throwable)}
				<li class='jm'>{@link oaj.RestServlet#getSessionObjects(RestRequest req, RestResponse res) getSessionObjects(RestRequest,RestResponse)}
			</ul>
		</ul>
		<br>The methods added for {@link oajr.RestInfoProvider} are:
		<ul>
			<li class='jac'>{@link oaj.RestServlet}
			<ul>
				<li class='jm'>{@link oaj.RestServlet#getSwagger(RestRequest) getSwagger(RestRequest)}
				<li class='jm'>{@link oaj.RestServlet#getSiteName(RestRequest) getSiteName(RestRequest)}
				<li class='jm'>{@link oaj.RestServlet#getTitle(RestRequest) getTitle(RestRequest)}
				<li class='jm'>{@link oaj.RestServlet#getDescription(RestRequest) getDescription(RestRequest)}
				<li class='jm'>{@link oaj.RestServlet#getMethodSummary(Method,RestRequest) getMethodSummary(Method,RestRequest)}
				<li class='jm'>{@link oaj.RestServlet#getMethodDescription(Method,RestRequest) getMethodDescription(Method,RestRequest)}
			</ul>
		</ul>
		<br>The methods added for {@link oajr.RestCallLogger} are:
		<ul>
			<li class='jac'>{@link oaj.RestServlet}
			<ul>
				<li class='jm'>{@link oaj.RestServlet#log(RestCallLoggerConfig,HttpServletRequest,HttpServletResponse) log(RestCallLoggerConfig,HttpServletRequest,HttpServletResponse)}
			</ul>
		</ul>
	<li>
		Added the following convenience hook methods on the {@link RestServlet} class:
		<ul>
			<li class='jac'>{@link oaj.RestServlet}
			<ul>
				<li class='jm'>{@link oaj.RestServlet#onInit(RestContextBuilder) onInit(RestContextBuilder)}
				<li class='jm'>{@link oaj.RestServlet#onPostInit(RestContext) onPostInit(RestContext)}
				<li class='jm'>{@link oaj.RestServlet#onPostInitChildFirst(RestContext) onPostInitChildFirst(RestContext)}
				<li class='jm'>{@link oaj.RestServlet#onDestroy(RestContext) onDestroy(RestContext)}
				<li class='jm'>{@link oaj.RestServlet#onStartCall(HttpServletRequest,HttpServletResponse) onStartCall(HttpServletRequest,HttpServletResponse)}
				<li class='jm'>{@link oaj.RestServlet#onPreCall(RestRequest,RestResponse) onPreCall(RestRequest,RestResponse)}
				<li class='jm'>{@link oaj.RestServlet#onPostCall(RestRequest,RestResponse) onPostCall(RestRequest,RestResponse)}
				<li class='jm'>{@link oaj.RestServlet#onEndCall(HttpServletRequest,HttpServletResponse) onEndCall(HttpServletRequest,HttpServletResponse)}
			</ul>
		</ul>
</ul>

<h5 class='topic w800'>juneau-rest-server-springboot</h5>
<ul class='spaced-list'>
	<li>
		{@link oajr.springboot.JuneauRestInitializer} now provides a no-arg constructor so that it can be used in
		the <c><ja>@ConfigurationContext</ja>(initializers=JuneauRestInitializer.<jk>class</jk>)</c> when unit testing
		using <ja>@SpringBootTest</ja>.
	<li>
		New {@link oajr.helper.ResourceDescription(String,String,String)} constructor and {@link oajr.helper.ResourceDescriptions#append(String,String,String)} method.
	<li>
		New {@link oajr.helper.Hyperlink} class.
</ul>

<h5 class='topic w800'>juneau-rest-client</h5>
<ul class='spaced-list'>
	<li>
		Completely revamped RestClient API.
		<ul>
			<li>All APIs now extend from HttpClient interfaces.
			<li>Better integration with HttpClient.
			<li>New fluent-style methods with many new convenience methods.
		</ul>
</ul>

<h5 class='topic w800'>juneau-doc</h5>
<ul class='spaced-list'>
</ul>
