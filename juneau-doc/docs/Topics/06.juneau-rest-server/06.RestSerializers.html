<!--
/***************************************************************************************************************************
 * Licensed to the Apache Software Foundation (ASF) under one or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *  
 *  http://www.apache.org/licenses/LICENSE-2.0
 *  
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations under the License.
 ***************************************************************************************************************************/
 -->

{title:'Marshalling', updated:'9.0.0'}

<p>
	Juneau uses {@link oaj.parser.Parser Parsers} and {@link oaj.serializer.Serializer Serializers} for marshalling
	HTTP request and response bodies to POJOs.  It uses the <c>Content-Type</c> header to match the best
	parser and the <c>Accept</c> header to match the best serializer.
</p>

<p>
	Serializers can be associated with REST servlets in the following ways:
</p>
<ul class='javatree'>
	<li class='ja'>
		{@link oajr.annotation.Rest#serializers() Rest(serializers)} 
		- Annotation on resource Java class.
	<li class='ja'>
		{@link oajr.annotation.RestOp#serializers() RestOp(serializers)} 
		- Annotation on resource Java method.
	<li class='jf'>
		{@del oajr.RestContext#REST_serializers} 
		- Programmatic.
</ul>

<p>
	The {@link oaj.http.annotation.Body @Body} annotation is used to identify POJOs to be used as the body of an HTTP request.
</p>
<h5 class='figure'>Examples:</h5>
<p class='bpcode w800'>
	<jc>// Defined on parameter</jc>
	<ja>@RestPost</ja>
	<jk>public void</jk> addPet(<ja>@Body</ja> Pet <jv>pet</jv>) {...}
</p>
<p class='bpcode w800'>
	<jc>// Defined on POJO class</jc>
	<ja>@RestPost</ja>
	<jk>public void</jk> addPet(Pet <jv>pet</jv>) {...}
	
	<ja>@Body</ja>
	<jk>public class</jk> Pet {...}
</p>







<p>
	This is functionally equivalent to the following code:
</p>
<p class='bpcode w800'>
	<ja>@RestPost</ja>
	<jk>public void</jk> addPet(RestRequest <jv>req</jv>) {
		Pet <jv>pet</jv> = <jv>req</jv>.getBody().as(Pet.<jk>class</jk>);
		...
	}
</p>
<p>
	In addition to {@link oaj.http.annotation.Body @Body}-annotated parameters/types, the body of an HTTP request
	can be retrieved by passing in parameters of the following types (matched in the specified order):
</p>
<ol class='spaced-list'>
	<li>
		{@link java.io.Reader}
		<br><ja>@Body</ja> annotation is optional.
		<br><c>Content-Type</c> is ignored.
	<li>
		{@link java.io.InputStream}
		<br><ja>@Body</ja> annotation is optional.
		<br><c>Content-Type</c> is ignored.
	<li>
		Any {@doc PojoCategories Parsable POJO} type.
		<br><c>Content-Type</c> is required to identify correct parser.
	<li>
		Objects convertible from {@link java.io.Reader} by having one of the following non-deprecated methods:
		<ul>
			<li><c><jk>public</jk> T(Reader in) {...}</c>
			<li><c><jk>public static</jk> T <jsm>create</jsm>(Reader in) {...}</c>
			<li><c><jk>public static</jk> T <jsm>fromReader</jsm>(Reader in) {...}</c>
		</ul>
		<c>Content-Type</c> must not be present or match an existing parser so that it's not parsed as a POJO.
	<li>
		Objects convertible from {@link java.io.InputStream} by having one of the following non-deprecated methods:
		<ul>
			<li><c><jk>public</jk> T(InputStream in) {...}</c>
			<li><c><jk>public static</jk> T <jsm>create</jsm>(InputStream in) {...}</c>
			<li><c><jk>public static</jk> T <jsm>fromInputStream</jsm>(InputStream in) {...}</c>
		</ul>
		<c>Content-Type</c> must not be present or match an existing parser so that it's not parsed as a POJO.
	<li>
		Objects convertible from {@link java.lang.String} by having one of the following non-deprecated methods:
		<ul>
			<li><c><jk>public</jk> T(String in) {...}</c>
			<li><c><jk>public static</jk> T <jsm>create</jsm>(String in) {...}</c>
			<li><c><jk>public static</jk> T <jsm>fromString</jsm>(String in) {...}</c>
			<li><c><jk>public static</jk> T <jsm>parse</jsm>(String in) {...}</c>
			<li><c><jk>public static</jk> T <jsm>parseString</jsm>(String in) {...}</c>
			<li><c><jk>public static</jk> T <jsm>forName</jsm>(String in) {...}</c>
			<li><c><jk>public static</jk> T <jsm>forString</jsm>(String in) {...}</c>
		</ul>
		Note that this also includes all enums.
	<li>
		Any {@link java.util.Optional} of anything on this list.
</ol>
<p>
	When used in combincation with  the mutable {@link oaj.Value} object, the {@link oaj.http.annotation.StatusCode @StatusCode} and {@link oaj.http.annotation.Header @Header} annotations 
	can be used on parameters {@link oajr.annotation.RestOp @RestOp}-annotated methods to 
	to define to response codes and headers.
</p>

 * <p>
 * Registers the following parsers for request bodies based on matching <c>Content-Type</c> header:
 * <ul class='javatreec'>
 * 	<li class='jc'>{@link JsonParser}
 * 	<li class='jc'>{@link SimpleJsonParser}
 * 	<li class='jc'>{@link XmlParser}
 * 	<li class='jc'>{@link HtmlParser}
 * 	<li class='jc'>{@link UonParser}
 * 	<li class='jc'>{@link UrlEncodingParser}
 * 	<li class='jc'>{@link OpenApiParser}
 * 	<li class='jc'>{@link MsgPackParser}
 * 	<li class='jc'>{@link PlainTextParser}
 * </ul>
 * 
* <p>
 * Registers the following serializers for response bodies based on matching <c>Accept</c> header:
 * <ul class='javatreec'>
 * 	<li class='jc'>{@link HtmlDocSerializer}
 * 	<li class='jc'>{@link HtmlStrippedDocSerializer}
 * 	<li class='jc'>{@link HtmlSchemaDocSerializer}
 * 	<li class='jc'>{@link JsonSerializer}
 * 	<li class='jc'>{@link SimpleJsonSerializer}
 * 	<li class='jc'>{@link JsonSchemaSerializer}
 * 	<li class='jc'>{@link XmlDocSerializer}
 * 	<li class='jc'>{@link UonSerializer}
 * 	<li class='jc'>{@link UrlEncodingSerializer}
 * 	<li class='jc'>{@link OpenApiSerializer}
 * 	<li class='jc'>{@link MsgPackSerializer}
 * 	<li class='jc'>{@link SoapXmlSerializer}
 * 	<li class='jc'>{@link PlainTextSerializer}
 * </ul>


<p>
	The following are all equivalent ways of defining serializers used by a resource:
</p> 		
<p class='bpcode w800'>
	<jc>// Option #1 - Defined via annotation.</jc>
	<ja>@Rest</ja>(serializers={JsonSerializer.<jk>class</jk>, XmlSerializer.<jk>class</jk>})
	<jk>public class</jk> MyResource {
		
		<jc>// Option #2 - Defined via builder passed in through resource constructor.</jc>
			<jk>public</jk> MyResource(RestContext.Builder <jv>builder</jv>) <jk>throws</jk> Exception {
			
			<jc>// Using method on builder.</jc>
			<jv>builder</jv>.serializers(JsonSerializer.<jk>class</jk>, XmlSerializer.<jk>class</jk>);

			<jc>// Same, but use pre-instantiated parsers.</jc>
			<jv>builder</jv>.serializers(JsonSerializer.<jsf>DEFAULT</jsf>, XmlSerializer.<jsf>DEFAULT</jsf>);

			<jc>// Same, but using property.</jc>
			<jv>builder</jv>.set(<jsf>REST_serializers</jsf>, JsonSerializer.<jk>class</jk>, XmlSerializer.<jk>class</jk>);
		}

		<jc>// Option #3 - Defined via builder passed in through init method.</jc>
		<ja>@RestHook</ja>(<jsf>INIT</jsf>)
		<jk>public void</jk> init(RestContext.Builder <jv>builder</jv>) <jk>throws</jk> Exception {
			<jv>builder</jv>.serializers(JsonSerializer.<jk>class</jk>, XmlSerializer.<jk>class</jk>);
		}

		<jc>// Override at the method level.</jc>
		<ja>@RestGet</ja>(serializers={HtmlSerializer.<jk>class</jk>})
		<jk>public</jk> MyPojo myMethod() {
			<jc>// Return a POJO to be serialized.</jc>
			<jk>return new</jk> MyPojo(); 
		}
	}
</p>

<ul class='seealso'>
	<li class='jf'>{@del oajr.RestContext#REST_serializers}
</ul>
